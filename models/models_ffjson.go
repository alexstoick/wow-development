// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: models/models.go
// DO NOT EDIT!

package models

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *AHFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AHFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"ID":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteString(`,"URL":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"LastModified":`)
	fflib.FormatBits2(buf, uint64(mj.LastModified), 10, mj.LastModified < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AHFilebase = iota
	ffj_t_AHFileno_such_key

	ffj_t_AHFile_ID

	ffj_t_AHFile_URL

	ffj_t_AHFile_LastModified
)

var ffj_key_AHFile_ID = []byte("ID")

var ffj_key_AHFile_URL = []byte("URL")

var ffj_key_AHFile_LastModified = []byte("LastModified")

func (uj *AHFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AHFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AHFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AHFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffj_key_AHFile_ID, kn) {
						currentKey = ffj_t_AHFile_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffj_key_AHFile_LastModified, kn) {
						currentKey = ffj_t_AHFile_LastModified
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_AHFile_URL, kn) {
						currentKey = ffj_t_AHFile_URL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AHFile_LastModified, kn) {
					currentKey = ffj_t_AHFile_LastModified
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AHFile_URL, kn) {
					currentKey = ffj_t_AHFile_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AHFile_ID, kn) {
					currentKey = ffj_t_AHFile_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AHFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AHFile_ID:
					goto handle_ID

				case ffj_t_AHFile_URL:
					goto handle_URL

				case ffj_t_AHFile_LastModified:
					goto handle_LastModified

				case ffj_t_AHFileno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModified:

	/* handler: uj.LastModified type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModified = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Auction) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Auction) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"auc":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteString(`,"item":`)
	fflib.FormatBits2(buf, uint64(mj.Item_id), 10, mj.Item_id < 0)
	buf.WriteString(`,"Owner":`)
	fflib.WriteJsonString(buf, string(mj.Owner))
	buf.WriteString(`,"OwnerRealm":`)
	fflib.WriteJsonString(buf, string(mj.OwnerRealm))
	buf.WriteString(`,"Bid":`)
	fflib.FormatBits2(buf, uint64(mj.Bid), 10, mj.Bid < 0)
	buf.WriteString(`,"Buyout":`)
	fflib.FormatBits2(buf, uint64(mj.Buyout), 10, mj.Buyout < 0)
	buf.WriteString(`,"Quantity":`)
	fflib.FormatBits2(buf, uint64(mj.Quantity), 10, mj.Quantity < 0)
	buf.WriteString(`,"TimeLeft":`)
	fflib.WriteJsonString(buf, string(mj.TimeLeft))
	buf.WriteString(`,"Rand":`)
	fflib.FormatBits2(buf, uint64(mj.Rand), 10, mj.Rand < 0)
	buf.WriteString(`,"Seed":`)
	fflib.FormatBits2(buf, uint64(mj.Seed), 10, mj.Seed < 0)
	buf.WriteString(`,"Context":`)
	fflib.FormatBits2(buf, uint64(mj.Context), 10, mj.Context < 0)
	buf.WriteString(`,"bonusLists":`)
	if mj.BonusList != nil {
		buf.WriteString(`[`)
		for i, v := range mj.BonusList {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Modifiers":`)
	if mj.Modifiers != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Modifiers {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"PetSpeciesId":`)
	fflib.FormatBits2(buf, uint64(mj.PetSpeciesId), 10, mj.PetSpeciesId < 0)
	buf.WriteString(`,"PetBreedId":`)
	fflib.FormatBits2(buf, uint64(mj.PetBreedId), 10, mj.PetBreedId < 0)
	buf.WriteString(`,"PetLevel":`)
	fflib.FormatBits2(buf, uint64(mj.PetLevel), 10, mj.PetLevel < 0)
	buf.WriteString(`,"PetQualityId":`)
	fflib.FormatBits2(buf, uint64(mj.PetQualityId), 10, mj.PetQualityId < 0)
	buf.WriteString(`,"ImportedFrom":`)

	{

		err = mj.ImportedFrom.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"ImportedAt":`)

	{

		obj, err = mj.ImportedAt.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Auctionbase = iota
	ffj_t_Auctionno_such_key

	ffj_t_Auction_ID

	ffj_t_Auction_Item_id

	ffj_t_Auction_Owner

	ffj_t_Auction_OwnerRealm

	ffj_t_Auction_Bid

	ffj_t_Auction_Buyout

	ffj_t_Auction_Quantity

	ffj_t_Auction_TimeLeft

	ffj_t_Auction_Rand

	ffj_t_Auction_Seed

	ffj_t_Auction_Context

	ffj_t_Auction_BonusList

	ffj_t_Auction_Modifiers

	ffj_t_Auction_PetSpeciesId

	ffj_t_Auction_PetBreedId

	ffj_t_Auction_PetLevel

	ffj_t_Auction_PetQualityId

	ffj_t_Auction_ImportedFrom

	ffj_t_Auction_ImportedAt
)

var ffj_key_Auction_ID = []byte("auc")

var ffj_key_Auction_Item_id = []byte("item")

var ffj_key_Auction_Owner = []byte("Owner")

var ffj_key_Auction_OwnerRealm = []byte("OwnerRealm")

var ffj_key_Auction_Bid = []byte("Bid")

var ffj_key_Auction_Buyout = []byte("Buyout")

var ffj_key_Auction_Quantity = []byte("Quantity")

var ffj_key_Auction_TimeLeft = []byte("TimeLeft")

var ffj_key_Auction_Rand = []byte("Rand")

var ffj_key_Auction_Seed = []byte("Seed")

var ffj_key_Auction_Context = []byte("Context")

var ffj_key_Auction_BonusList = []byte("bonusLists")

var ffj_key_Auction_Modifiers = []byte("Modifiers")

var ffj_key_Auction_PetSpeciesId = []byte("PetSpeciesId")

var ffj_key_Auction_PetBreedId = []byte("PetBreedId")

var ffj_key_Auction_PetLevel = []byte("PetLevel")

var ffj_key_Auction_PetQualityId = []byte("PetQualityId")

var ffj_key_Auction_ImportedFrom = []byte("ImportedFrom")

var ffj_key_Auction_ImportedAt = []byte("ImportedAt")

func (uj *Auction) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Auction) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Auctionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Auctionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'B':

					if bytes.Equal(ffj_key_Auction_Bid, kn) {
						currentKey = ffj_t_Auction_Bid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_Buyout, kn) {
						currentKey = ffj_t_Auction_Buyout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_Auction_Context, kn) {
						currentKey = ffj_t_Auction_Context
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_Auction_ImportedFrom, kn) {
						currentKey = ffj_t_Auction_ImportedFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_ImportedAt, kn) {
						currentKey = ffj_t_Auction_ImportedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_Auction_Modifiers, kn) {
						currentKey = ffj_t_Auction_Modifiers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_Auction_Owner, kn) {
						currentKey = ffj_t_Auction_Owner
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_OwnerRealm, kn) {
						currentKey = ffj_t_Auction_OwnerRealm
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_Auction_PetSpeciesId, kn) {
						currentKey = ffj_t_Auction_PetSpeciesId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_PetBreedId, kn) {
						currentKey = ffj_t_Auction_PetBreedId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_PetLevel, kn) {
						currentKey = ffj_t_Auction_PetLevel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Auction_PetQualityId, kn) {
						currentKey = ffj_t_Auction_PetQualityId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffj_key_Auction_Quantity, kn) {
						currentKey = ffj_t_Auction_Quantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_Auction_Rand, kn) {
						currentKey = ffj_t_Auction_Rand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_Auction_Seed, kn) {
						currentKey = ffj_t_Auction_Seed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_Auction_TimeLeft, kn) {
						currentKey = ffj_t_Auction_TimeLeft
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffj_key_Auction_ID, kn) {
						currentKey = ffj_t_Auction_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_Auction_BonusList, kn) {
						currentKey = ffj_t_Auction_BonusList
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Auction_Item_id, kn) {
						currentKey = ffj_t_Auction_Item_id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_ImportedAt, kn) {
					currentKey = ffj_t_Auction_ImportedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_ImportedFrom, kn) {
					currentKey = ffj_t_Auction_ImportedFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_PetQualityId, kn) {
					currentKey = ffj_t_Auction_PetQualityId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_PetLevel, kn) {
					currentKey = ffj_t_Auction_PetLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_PetBreedId, kn) {
					currentKey = ffj_t_Auction_PetBreedId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Auction_PetSpeciesId, kn) {
					currentKey = ffj_t_Auction_PetSpeciesId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Auction_Modifiers, kn) {
					currentKey = ffj_t_Auction_Modifiers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Auction_BonusList, kn) {
					currentKey = ffj_t_Auction_BonusList
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Context, kn) {
					currentKey = ffj_t_Auction_Context
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Auction_Seed, kn) {
					currentKey = ffj_t_Auction_Seed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Rand, kn) {
					currentKey = ffj_t_Auction_Rand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_TimeLeft, kn) {
					currentKey = ffj_t_Auction_TimeLeft
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Quantity, kn) {
					currentKey = ffj_t_Auction_Quantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Buyout, kn) {
					currentKey = ffj_t_Auction_Buyout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Bid, kn) {
					currentKey = ffj_t_Auction_Bid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_OwnerRealm, kn) {
					currentKey = ffj_t_Auction_OwnerRealm
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Owner, kn) {
					currentKey = ffj_t_Auction_Owner
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_Item_id, kn) {
					currentKey = ffj_t_Auction_Item_id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Auction_ID, kn) {
					currentKey = ffj_t_Auction_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Auctionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Auction_ID:
					goto handle_ID

				case ffj_t_Auction_Item_id:
					goto handle_Item_id

				case ffj_t_Auction_Owner:
					goto handle_Owner

				case ffj_t_Auction_OwnerRealm:
					goto handle_OwnerRealm

				case ffj_t_Auction_Bid:
					goto handle_Bid

				case ffj_t_Auction_Buyout:
					goto handle_Buyout

				case ffj_t_Auction_Quantity:
					goto handle_Quantity

				case ffj_t_Auction_TimeLeft:
					goto handle_TimeLeft

				case ffj_t_Auction_Rand:
					goto handle_Rand

				case ffj_t_Auction_Seed:
					goto handle_Seed

				case ffj_t_Auction_Context:
					goto handle_Context

				case ffj_t_Auction_BonusList:
					goto handle_BonusList

				case ffj_t_Auction_Modifiers:
					goto handle_Modifiers

				case ffj_t_Auction_PetSpeciesId:
					goto handle_PetSpeciesId

				case ffj_t_Auction_PetBreedId:
					goto handle_PetBreedId

				case ffj_t_Auction_PetLevel:
					goto handle_PetLevel

				case ffj_t_Auction_PetQualityId:
					goto handle_PetQualityId

				case ffj_t_Auction_ImportedFrom:
					goto handle_ImportedFrom

				case ffj_t_Auction_ImportedAt:
					goto handle_ImportedAt

				case ffj_t_Auctionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Item_id:

	/* handler: uj.Item_id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Item_id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Owner:

	/* handler: uj.Owner type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Owner = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OwnerRealm:

	/* handler: uj.OwnerRealm type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OwnerRealm = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bid:

	/* handler: uj.Bid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Bid = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Buyout:

	/* handler: uj.Buyout type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Buyout = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: uj.Quantity type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Quantity = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeLeft:

	/* handler: uj.TimeLeft type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.TimeLeft = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rand:

	/* handler: uj.Rand type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Rand = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Seed:

	/* handler: uj.Seed type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Seed = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Context:

	/* handler: uj.Context type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Context = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BonusList:

	/* handler: uj.BonusList type=[]models.Bonus kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.BonusList = nil
		} else {

			uj.BonusList = make([]Bonus, 0)

			wantVal := true

			for {

				var v Bonus

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=models.Bonus kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.BonusList = append(uj.BonusList, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Modifiers:

	/* handler: uj.Modifiers type=[]models.Modifier kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Modifiers = nil
		} else {

			uj.Modifiers = make([]Modifier, 0)

			wantVal := true

			for {

				var v Modifier

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=models.Modifier kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Modifiers = append(uj.Modifiers, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PetSpeciesId:

	/* handler: uj.PetSpeciesId type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.PetSpeciesId = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PetBreedId:

	/* handler: uj.PetBreedId type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.PetBreedId = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PetLevel:

	/* handler: uj.PetLevel type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.PetLevel = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PetQualityId:

	/* handler: uj.PetQualityId type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.PetQualityId = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImportedFrom:

	/* handler: uj.ImportedFrom type=models.AHFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ImportedFrom.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImportedAt:

	/* handler: uj.ImportedAt type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.ImportedAt.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Bonus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Bonus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"bonusListId":`)
	fflib.FormatBits2(buf, uint64(mj.Id), 10, mj.Id < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Bonusbase = iota
	ffj_t_Bonusno_such_key

	ffj_t_Bonus_Id
)

var ffj_key_Bonus_Id = []byte("bonusListId")

func (uj *Bonus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Bonus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Bonusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Bonusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_Bonus_Id, kn) {
						currentKey = ffj_t_Bonus_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Bonus_Id, kn) {
					currentKey = ffj_t_Bonus_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Bonusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Bonus_Id:
					goto handle_Id

				case ffj_t_Bonusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Item) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Item) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"ItemID":`)
	fflib.FormatBits2(buf, uint64(mj.ItemID), 10, mj.ItemID < 0)
	buf.WriteString(`,"ItemName":`)
	fflib.WriteJsonString(buf, string(mj.ItemName))
	buf.WriteString(`,"InBlizzardAPI":`)
	fflib.FormatBits2(buf, uint64(mj.InBlizzardAPI), 10, mj.InBlizzardAPI < 0)
	buf.WriteString(`,"InWowheadAPI":`)
	fflib.FormatBits2(buf, uint64(mj.InWowheadAPI), 10, mj.InWowheadAPI < 0)
	buf.WriteString(`,"IsAuctionable":`)
	fflib.FormatBits2(buf, uint64(mj.IsAuctionable), 10, mj.IsAuctionable < 0)
	buf.WriteString(`,"GlobalMedianEU":`)
	fflib.FormatBits2(buf, uint64(mj.GlobalMedianEU), 10, mj.GlobalMedianEU < 0)
	buf.WriteString(`,"Alchemy":`)
	fflib.FormatBits2(buf, uint64(mj.Alchemy), 10, mj.Alchemy < 0)
	buf.WriteString(`,"Archaeology":`)
	fflib.FormatBits2(buf, uint64(mj.Archaeology), 10, mj.Archaeology < 0)
	buf.WriteString(`,"Blacksmithing":`)
	fflib.FormatBits2(buf, uint64(mj.Blacksmithing), 10, mj.Blacksmithing < 0)
	buf.WriteString(`,"Cooking":`)
	fflib.FormatBits2(buf, uint64(mj.Cooking), 10, mj.Cooking < 0)
	buf.WriteString(`,"Disenchanting":`)
	fflib.FormatBits2(buf, uint64(mj.Disenchanting), 10, mj.Disenchanting < 0)
	buf.WriteString(`,"Enchanting":`)
	fflib.FormatBits2(buf, uint64(mj.Enchanting), 10, mj.Enchanting < 0)
	buf.WriteString(`,"Engineering":`)
	fflib.FormatBits2(buf, uint64(mj.Engineering), 10, mj.Engineering < 0)
	buf.WriteString(`,"Firstaid":`)
	fflib.FormatBits2(buf, uint64(mj.Firstaid), 10, mj.Firstaid < 0)
	buf.WriteString(`,"Herbalism":`)
	fflib.FormatBits2(buf, uint64(mj.Herbalism), 10, mj.Herbalism < 0)
	buf.WriteString(`,"Inscription":`)
	fflib.FormatBits2(buf, uint64(mj.Inscription), 10, mj.Inscription < 0)
	buf.WriteString(`,"Jewelcrafting":`)
	fflib.FormatBits2(buf, uint64(mj.Jewelcrafting), 10, mj.Jewelcrafting < 0)
	buf.WriteString(`,"Leatherworking":`)
	fflib.FormatBits2(buf, uint64(mj.Leatherworking), 10, mj.Leatherworking < 0)
	buf.WriteString(`,"Milling":`)
	fflib.FormatBits2(buf, uint64(mj.Milling), 10, mj.Milling < 0)
	buf.WriteString(`,"Mining":`)
	fflib.FormatBits2(buf, uint64(mj.Mining), 10, mj.Mining < 0)
	buf.WriteString(`,"Prospecting":`)
	fflib.FormatBits2(buf, uint64(mj.Prospecting), 10, mj.Prospecting < 0)
	buf.WriteString(`,"Skinning":`)
	fflib.FormatBits2(buf, uint64(mj.Skinning), 10, mj.Skinning < 0)
	buf.WriteString(`,"Tailoring":`)
	fflib.FormatBits2(buf, uint64(mj.Tailoring), 10, mj.Tailoring < 0)
	buf.WriteString(`,"StackSize":`)
	fflib.FormatBits2(buf, uint64(mj.StackSize), 10, mj.StackSize < 0)
	buf.WriteString(`,"BuyPrice":`)
	fflib.FormatBits2(buf, uint64(mj.BuyPrice), 10, mj.BuyPrice < 0)
	buf.WriteString(`,"SellPrice":`)
	fflib.FormatBits2(buf, uint64(mj.SellPrice), 10, mj.SellPrice < 0)
	buf.WriteString(`,"ItemClass":`)
	fflib.WriteJsonString(buf, string(mj.ItemClass))
	buf.WriteString(`,"ItemSubClass":`)
	fflib.WriteJsonString(buf, string(mj.ItemSubClass))
	buf.WriteString(`,"ItemType":`)
	fflib.WriteJsonString(buf, string(mj.ItemType))
	buf.WriteString(`,"InventoryType":`)
	fflib.WriteJsonString(buf, string(mj.InventoryType))
	buf.WriteString(`,"Equippable":`)
	fflib.FormatBits2(buf, uint64(mj.Equippable), 10, mj.Equippable < 0)
	buf.WriteString(`,"Source":`)
	fflib.WriteJsonString(buf, string(mj.Source))
	buf.WriteString(`,"SourceId":`)
	fflib.FormatBits2(buf, uint64(mj.SourceId), 10, mj.SourceId < 0)
	buf.WriteString(`,"SourceType":`)
	fflib.WriteJsonString(buf, string(mj.SourceType))
	buf.WriteString(`,"SourceDesc":`)
	fflib.WriteJsonString(buf, string(mj.SourceDesc))
	buf.WriteString(`,"DeprecatedMsg":`)
	fflib.WriteJsonString(buf, string(mj.DeprecatedMsg))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Itembase = iota
	ffj_t_Itemno_such_key

	ffj_t_Item_ItemID

	ffj_t_Item_ItemName

	ffj_t_Item_InBlizzardAPI

	ffj_t_Item_InWowheadAPI

	ffj_t_Item_IsAuctionable

	ffj_t_Item_GlobalMedianEU

	ffj_t_Item_Alchemy

	ffj_t_Item_Archaeology

	ffj_t_Item_Blacksmithing

	ffj_t_Item_Cooking

	ffj_t_Item_Disenchanting

	ffj_t_Item_Enchanting

	ffj_t_Item_Engineering

	ffj_t_Item_Firstaid

	ffj_t_Item_Herbalism

	ffj_t_Item_Inscription

	ffj_t_Item_Jewelcrafting

	ffj_t_Item_Leatherworking

	ffj_t_Item_Milling

	ffj_t_Item_Mining

	ffj_t_Item_Prospecting

	ffj_t_Item_Skinning

	ffj_t_Item_Tailoring

	ffj_t_Item_StackSize

	ffj_t_Item_BuyPrice

	ffj_t_Item_SellPrice

	ffj_t_Item_ItemClass

	ffj_t_Item_ItemSubClass

	ffj_t_Item_ItemType

	ffj_t_Item_InventoryType

	ffj_t_Item_Equippable

	ffj_t_Item_Source

	ffj_t_Item_SourceId

	ffj_t_Item_SourceType

	ffj_t_Item_SourceDesc

	ffj_t_Item_DeprecatedMsg
)

var ffj_key_Item_ItemID = []byte("ItemID")

var ffj_key_Item_ItemName = []byte("ItemName")

var ffj_key_Item_InBlizzardAPI = []byte("InBlizzardAPI")

var ffj_key_Item_InWowheadAPI = []byte("InWowheadAPI")

var ffj_key_Item_IsAuctionable = []byte("IsAuctionable")

var ffj_key_Item_GlobalMedianEU = []byte("GlobalMedianEU")

var ffj_key_Item_Alchemy = []byte("Alchemy")

var ffj_key_Item_Archaeology = []byte("Archaeology")

var ffj_key_Item_Blacksmithing = []byte("Blacksmithing")

var ffj_key_Item_Cooking = []byte("Cooking")

var ffj_key_Item_Disenchanting = []byte("Disenchanting")

var ffj_key_Item_Enchanting = []byte("Enchanting")

var ffj_key_Item_Engineering = []byte("Engineering")

var ffj_key_Item_Firstaid = []byte("Firstaid")

var ffj_key_Item_Herbalism = []byte("Herbalism")

var ffj_key_Item_Inscription = []byte("Inscription")

var ffj_key_Item_Jewelcrafting = []byte("Jewelcrafting")

var ffj_key_Item_Leatherworking = []byte("Leatherworking")

var ffj_key_Item_Milling = []byte("Milling")

var ffj_key_Item_Mining = []byte("Mining")

var ffj_key_Item_Prospecting = []byte("Prospecting")

var ffj_key_Item_Skinning = []byte("Skinning")

var ffj_key_Item_Tailoring = []byte("Tailoring")

var ffj_key_Item_StackSize = []byte("StackSize")

var ffj_key_Item_BuyPrice = []byte("BuyPrice")

var ffj_key_Item_SellPrice = []byte("SellPrice")

var ffj_key_Item_ItemClass = []byte("ItemClass")

var ffj_key_Item_ItemSubClass = []byte("ItemSubClass")

var ffj_key_Item_ItemType = []byte("ItemType")

var ffj_key_Item_InventoryType = []byte("InventoryType")

var ffj_key_Item_Equippable = []byte("Equippable")

var ffj_key_Item_Source = []byte("Source")

var ffj_key_Item_SourceId = []byte("SourceId")

var ffj_key_Item_SourceType = []byte("SourceType")

var ffj_key_Item_SourceDesc = []byte("SourceDesc")

var ffj_key_Item_DeprecatedMsg = []byte("DeprecatedMsg")

func (uj *Item) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Item) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Itembase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Itemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_Item_Alchemy, kn) {
						currentKey = ffj_t_Item_Alchemy
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Archaeology, kn) {
						currentKey = ffj_t_Item_Archaeology
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'B':

					if bytes.Equal(ffj_key_Item_Blacksmithing, kn) {
						currentKey = ffj_t_Item_Blacksmithing
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_BuyPrice, kn) {
						currentKey = ffj_t_Item_BuyPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_Item_Cooking, kn) {
						currentKey = ffj_t_Item_Cooking
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffj_key_Item_Disenchanting, kn) {
						currentKey = ffj_t_Item_Disenchanting
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_DeprecatedMsg, kn) {
						currentKey = ffj_t_Item_DeprecatedMsg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffj_key_Item_Enchanting, kn) {
						currentKey = ffj_t_Item_Enchanting
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Engineering, kn) {
						currentKey = ffj_t_Item_Engineering
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Equippable, kn) {
						currentKey = ffj_t_Item_Equippable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_Item_Firstaid, kn) {
						currentKey = ffj_t_Item_Firstaid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'G':

					if bytes.Equal(ffj_key_Item_GlobalMedianEU, kn) {
						currentKey = ffj_t_Item_GlobalMedianEU
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffj_key_Item_Herbalism, kn) {
						currentKey = ffj_t_Item_Herbalism
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_Item_ItemID, kn) {
						currentKey = ffj_t_Item_ItemID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_ItemName, kn) {
						currentKey = ffj_t_Item_ItemName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_InBlizzardAPI, kn) {
						currentKey = ffj_t_Item_InBlizzardAPI
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_InWowheadAPI, kn) {
						currentKey = ffj_t_Item_InWowheadAPI
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_IsAuctionable, kn) {
						currentKey = ffj_t_Item_IsAuctionable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Inscription, kn) {
						currentKey = ffj_t_Item_Inscription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_ItemClass, kn) {
						currentKey = ffj_t_Item_ItemClass
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_ItemSubClass, kn) {
						currentKey = ffj_t_Item_ItemSubClass
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_ItemType, kn) {
						currentKey = ffj_t_Item_ItemType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_InventoryType, kn) {
						currentKey = ffj_t_Item_InventoryType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'J':

					if bytes.Equal(ffj_key_Item_Jewelcrafting, kn) {
						currentKey = ffj_t_Item_Jewelcrafting
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffj_key_Item_Leatherworking, kn) {
						currentKey = ffj_t_Item_Leatherworking
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_Item_Milling, kn) {
						currentKey = ffj_t_Item_Milling
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Mining, kn) {
						currentKey = ffj_t_Item_Mining
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_Item_Prospecting, kn) {
						currentKey = ffj_t_Item_Prospecting
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_Item_Skinning, kn) {
						currentKey = ffj_t_Item_Skinning
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_StackSize, kn) {
						currentKey = ffj_t_Item_StackSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_SellPrice, kn) {
						currentKey = ffj_t_Item_SellPrice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_Source, kn) {
						currentKey = ffj_t_Item_Source
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_SourceId, kn) {
						currentKey = ffj_t_Item_SourceId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_SourceType, kn) {
						currentKey = ffj_t_Item_SourceType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Item_SourceDesc, kn) {
						currentKey = ffj_t_Item_SourceDesc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_Item_Tailoring, kn) {
						currentKey = ffj_t_Item_Tailoring
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Item_DeprecatedMsg, kn) {
					currentKey = ffj_t_Item_DeprecatedMsg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_SourceDesc, kn) {
					currentKey = ffj_t_Item_SourceDesc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_SourceType, kn) {
					currentKey = ffj_t_Item_SourceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_SourceId, kn) {
					currentKey = ffj_t_Item_SourceId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Source, kn) {
					currentKey = ffj_t_Item_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Equippable, kn) {
					currentKey = ffj_t_Item_Equippable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_InventoryType, kn) {
					currentKey = ffj_t_Item_InventoryType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_ItemType, kn) {
					currentKey = ffj_t_Item_ItemType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_ItemSubClass, kn) {
					currentKey = ffj_t_Item_ItemSubClass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_ItemClass, kn) {
					currentKey = ffj_t_Item_ItemClass
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_SellPrice, kn) {
					currentKey = ffj_t_Item_SellPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_BuyPrice, kn) {
					currentKey = ffj_t_Item_BuyPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_StackSize, kn) {
					currentKey = ffj_t_Item_StackSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Tailoring, kn) {
					currentKey = ffj_t_Item_Tailoring
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Skinning, kn) {
					currentKey = ffj_t_Item_Skinning
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Prospecting, kn) {
					currentKey = ffj_t_Item_Prospecting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Mining, kn) {
					currentKey = ffj_t_Item_Mining
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Milling, kn) {
					currentKey = ffj_t_Item_Milling
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Leatherworking, kn) {
					currentKey = ffj_t_Item_Leatherworking
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Jewelcrafting, kn) {
					currentKey = ffj_t_Item_Jewelcrafting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Inscription, kn) {
					currentKey = ffj_t_Item_Inscription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Herbalism, kn) {
					currentKey = ffj_t_Item_Herbalism
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Firstaid, kn) {
					currentKey = ffj_t_Item_Firstaid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Engineering, kn) {
					currentKey = ffj_t_Item_Engineering
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Enchanting, kn) {
					currentKey = ffj_t_Item_Enchanting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Disenchanting, kn) {
					currentKey = ffj_t_Item_Disenchanting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Cooking, kn) {
					currentKey = ffj_t_Item_Cooking
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_Blacksmithing, kn) {
					currentKey = ffj_t_Item_Blacksmithing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Archaeology, kn) {
					currentKey = ffj_t_Item_Archaeology
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_Alchemy, kn) {
					currentKey = ffj_t_Item_Alchemy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_GlobalMedianEU, kn) {
					currentKey = ffj_t_Item_GlobalMedianEU
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Item_IsAuctionable, kn) {
					currentKey = ffj_t_Item_IsAuctionable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_InWowheadAPI, kn) {
					currentKey = ffj_t_Item_InWowheadAPI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_InBlizzardAPI, kn) {
					currentKey = ffj_t_Item_InBlizzardAPI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_ItemName, kn) {
					currentKey = ffj_t_Item_ItemName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Item_ItemID, kn) {
					currentKey = ffj_t_Item_ItemID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Itemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Item_ItemID:
					goto handle_ItemID

				case ffj_t_Item_ItemName:
					goto handle_ItemName

				case ffj_t_Item_InBlizzardAPI:
					goto handle_InBlizzardAPI

				case ffj_t_Item_InWowheadAPI:
					goto handle_InWowheadAPI

				case ffj_t_Item_IsAuctionable:
					goto handle_IsAuctionable

				case ffj_t_Item_GlobalMedianEU:
					goto handle_GlobalMedianEU

				case ffj_t_Item_Alchemy:
					goto handle_Alchemy

				case ffj_t_Item_Archaeology:
					goto handle_Archaeology

				case ffj_t_Item_Blacksmithing:
					goto handle_Blacksmithing

				case ffj_t_Item_Cooking:
					goto handle_Cooking

				case ffj_t_Item_Disenchanting:
					goto handle_Disenchanting

				case ffj_t_Item_Enchanting:
					goto handle_Enchanting

				case ffj_t_Item_Engineering:
					goto handle_Engineering

				case ffj_t_Item_Firstaid:
					goto handle_Firstaid

				case ffj_t_Item_Herbalism:
					goto handle_Herbalism

				case ffj_t_Item_Inscription:
					goto handle_Inscription

				case ffj_t_Item_Jewelcrafting:
					goto handle_Jewelcrafting

				case ffj_t_Item_Leatherworking:
					goto handle_Leatherworking

				case ffj_t_Item_Milling:
					goto handle_Milling

				case ffj_t_Item_Mining:
					goto handle_Mining

				case ffj_t_Item_Prospecting:
					goto handle_Prospecting

				case ffj_t_Item_Skinning:
					goto handle_Skinning

				case ffj_t_Item_Tailoring:
					goto handle_Tailoring

				case ffj_t_Item_StackSize:
					goto handle_StackSize

				case ffj_t_Item_BuyPrice:
					goto handle_BuyPrice

				case ffj_t_Item_SellPrice:
					goto handle_SellPrice

				case ffj_t_Item_ItemClass:
					goto handle_ItemClass

				case ffj_t_Item_ItemSubClass:
					goto handle_ItemSubClass

				case ffj_t_Item_ItemType:
					goto handle_ItemType

				case ffj_t_Item_InventoryType:
					goto handle_InventoryType

				case ffj_t_Item_Equippable:
					goto handle_Equippable

				case ffj_t_Item_Source:
					goto handle_Source

				case ffj_t_Item_SourceId:
					goto handle_SourceId

				case ffj_t_Item_SourceType:
					goto handle_SourceType

				case ffj_t_Item_SourceDesc:
					goto handle_SourceDesc

				case ffj_t_Item_DeprecatedMsg:
					goto handle_DeprecatedMsg

				case ffj_t_Itemno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ItemID:

	/* handler: uj.ItemID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ItemID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItemName:

	/* handler: uj.ItemName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ItemName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InBlizzardAPI:

	/* handler: uj.InBlizzardAPI type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InBlizzardAPI = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InWowheadAPI:

	/* handler: uj.InWowheadAPI type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InWowheadAPI = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAuctionable:

	/* handler: uj.IsAuctionable type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.IsAuctionable = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GlobalMedianEU:

	/* handler: uj.GlobalMedianEU type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.GlobalMedianEU = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Alchemy:

	/* handler: uj.Alchemy type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Alchemy = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Archaeology:

	/* handler: uj.Archaeology type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Archaeology = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Blacksmithing:

	/* handler: uj.Blacksmithing type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Blacksmithing = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cooking:

	/* handler: uj.Cooking type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cooking = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Disenchanting:

	/* handler: uj.Disenchanting type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Disenchanting = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Enchanting:

	/* handler: uj.Enchanting type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Enchanting = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Engineering:

	/* handler: uj.Engineering type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Engineering = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Firstaid:

	/* handler: uj.Firstaid type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Firstaid = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Herbalism:

	/* handler: uj.Herbalism type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Herbalism = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inscription:

	/* handler: uj.Inscription type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Inscription = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Jewelcrafting:

	/* handler: uj.Jewelcrafting type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Jewelcrafting = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Leatherworking:

	/* handler: uj.Leatherworking type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Leatherworking = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Milling:

	/* handler: uj.Milling type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Milling = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mining:

	/* handler: uj.Mining type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Mining = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Prospecting:

	/* handler: uj.Prospecting type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Prospecting = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Skinning:

	/* handler: uj.Skinning type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Skinning = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tailoring:

	/* handler: uj.Tailoring type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Tailoring = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StackSize:

	/* handler: uj.StackSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.StackSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BuyPrice:

	/* handler: uj.BuyPrice type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.BuyPrice = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SellPrice:

	/* handler: uj.SellPrice type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SellPrice = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItemClass:

	/* handler: uj.ItemClass type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ItemClass = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItemSubClass:

	/* handler: uj.ItemSubClass type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ItemSubClass = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItemType:

	/* handler: uj.ItemType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ItemType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InventoryType:

	/* handler: uj.InventoryType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InventoryType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Equippable:

	/* handler: uj.Equippable type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Equippable = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Source = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SourceId:

	/* handler: uj.SourceId type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.SourceId = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SourceType:

	/* handler: uj.SourceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SourceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SourceDesc:

	/* handler: uj.SourceDesc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SourceDesc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeprecatedMsg:

	/* handler: uj.DeprecatedMsg type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DeprecatedMsg = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ItemMaterial) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ItemMaterial) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"ID":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteString(`,"ItemID":`)
	fflib.FormatBits2(buf, uint64(mj.ItemID), 10, mj.ItemID < 0)
	buf.WriteString(`,"MaterialID":`)
	fflib.FormatBits2(buf, uint64(mj.MaterialID), 10, mj.MaterialID < 0)
	buf.WriteString(`,"Quantity":`)
	fflib.FormatBits2(buf, uint64(mj.Quantity), 10, mj.Quantity < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ItemMaterialbase = iota
	ffj_t_ItemMaterialno_such_key

	ffj_t_ItemMaterial_ID

	ffj_t_ItemMaterial_ItemID

	ffj_t_ItemMaterial_MaterialID

	ffj_t_ItemMaterial_Quantity
)

var ffj_key_ItemMaterial_ID = []byte("ID")

var ffj_key_ItemMaterial_ItemID = []byte("ItemID")

var ffj_key_ItemMaterial_MaterialID = []byte("MaterialID")

var ffj_key_ItemMaterial_Quantity = []byte("Quantity")

func (uj *ItemMaterial) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ItemMaterial) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ItemMaterialbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ItemMaterialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffj_key_ItemMaterial_ID, kn) {
						currentKey = ffj_t_ItemMaterial_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ItemMaterial_ItemID, kn) {
						currentKey = ffj_t_ItemMaterial_ItemID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_ItemMaterial_MaterialID, kn) {
						currentKey = ffj_t_ItemMaterial_MaterialID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffj_key_ItemMaterial_Quantity, kn) {
						currentKey = ffj_t_ItemMaterial_Quantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ItemMaterial_Quantity, kn) {
					currentKey = ffj_t_ItemMaterial_Quantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ItemMaterial_MaterialID, kn) {
					currentKey = ffj_t_ItemMaterial_MaterialID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ItemMaterial_ItemID, kn) {
					currentKey = ffj_t_ItemMaterial_ItemID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ItemMaterial_ID, kn) {
					currentKey = ffj_t_ItemMaterial_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ItemMaterialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ItemMaterial_ID:
					goto handle_ID

				case ffj_t_ItemMaterial_ItemID:
					goto handle_ItemID

				case ffj_t_ItemMaterial_MaterialID:
					goto handle_MaterialID

				case ffj_t_ItemMaterial_Quantity:
					goto handle_Quantity

				case ffj_t_ItemMaterialno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItemID:

	/* handler: uj.ItemID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ItemID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaterialID:

	/* handler: uj.MaterialID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MaterialID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quantity:

	/* handler: uj.Quantity type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Quantity = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Modifier) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Modifier) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Type":`)
	fflib.FormatBits2(buf, uint64(mj.Type), 10, mj.Type < 0)
	buf.WriteString(`,"Value":`)
	fflib.FormatBits2(buf, uint64(mj.Value), 10, mj.Value < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Modifierbase = iota
	ffj_t_Modifierno_such_key

	ffj_t_Modifier_Type

	ffj_t_Modifier_Value
)

var ffj_key_Modifier_Type = []byte("Type")

var ffj_key_Modifier_Value = []byte("Value")

func (uj *Modifier) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Modifier) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Modifierbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Modifierno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'T':

					if bytes.Equal(ffj_key_Modifier_Type, kn) {
						currentKey = ffj_t_Modifier_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'V':

					if bytes.Equal(ffj_key_Modifier_Value, kn) {
						currentKey = ffj_t_Modifier_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Modifier_Value, kn) {
					currentKey = ffj_t_Modifier_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Modifier_Type, kn) {
					currentKey = ffj_t_Modifier_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Modifierno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Modifier_Type:
					goto handle_Type

				case ffj_t_Modifier_Value:
					goto handle_Value

				case ffj_t_Modifierno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Type = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Value = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Realm) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Realm) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"Slug":`)
	fflib.WriteJsonString(buf, string(mj.Slug))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Realmbase = iota
	ffj_t_Realmno_such_key

	ffj_t_Realm_Name

	ffj_t_Realm_Slug
)

var ffj_key_Realm_Name = []byte("Name")

var ffj_key_Realm_Slug = []byte("Slug")

func (uj *Realm) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Realm) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Realmbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Realmno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'N':

					if bytes.Equal(ffj_key_Realm_Name, kn) {
						currentKey = ffj_t_Realm_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_Realm_Slug, kn) {
						currentKey = ffj_t_Realm_Slug
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Realm_Slug, kn) {
					currentKey = ffj_t_Realm_Slug
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Realm_Name, kn) {
					currentKey = ffj_t_Realm_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Realmno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Realm_Name:
					goto handle_Name

				case ffj_t_Realm_Slug:
					goto handle_Slug

				case ffj_t_Realmno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slug:

	/* handler: uj.Slug type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Slug = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
